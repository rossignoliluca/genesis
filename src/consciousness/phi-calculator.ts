/**
 * Genesis 6.0 - φ Calculator (IIT 4.0)
 *
 * Integrated Information Theory implementation.
 * Calculates φ (phi) - the amount of integrated information in a system.
 *
 * Key concept: A system is conscious to the degree that it has
 * integrated information - information that is generated by the
 * system as a whole, above and beyond its parts.
 *
 * References:
 * - Tononi, G. (2004). An information integration theory of consciousness.
 * - Tononi, G. et al. (2016). Integrated information theory: from consciousness to its physical substrate.
 * - Oizumi, M. et al. (2014). From the phenomenology to the mechanisms of consciousness.
 *
 * Note: Exact φ calculation is NP-hard (exponential in system size).
 * This implementation uses approximations for tractability.
 *
 * Usage:
 * ```typescript
 * import { createPhiCalculator } from './consciousness/phi-calculator.js';
 *
 * const calculator = createPhiCalculator({ approximationLevel: 'fast' });
 *
 * const result = calculator.calculate(systemState);
 * console.log(`φ = ${result.phi}`);
 * ```
 */

import { randomUUID } from 'crypto';
import {
  SystemState,
  ComponentState,
  Connection,
  Partition,
  Cut,
  PhiResult,
  Complex,
} from './types.js';

// ============================================================================
// Configuration
// ============================================================================

export interface PhiCalculatorConfig {
  approximationLevel: 'exact' | 'fast' | 'faster';
  maxPartitions: number;             // Limit partitions for approximation
  cacheResults: boolean;
  cacheTTL: number;                  // Cache time-to-live (ms)
}

export const DEFAULT_PHI_CONFIG: PhiCalculatorConfig = {
  approximationLevel: 'fast',
  maxPartitions: 100,
  cacheResults: true,
  cacheTTL: 5000,
};

// ============================================================================
// φ Calculator
// ============================================================================

export class PhiCalculator {
  private config: PhiCalculatorConfig;
  private cache: Map<string, { result: PhiResult; timestamp: number }> = new Map();

  constructor(config: Partial<PhiCalculatorConfig> = {}) {
    this.config = { ...DEFAULT_PHI_CONFIG, ...config };
  }

  // ============================================================================
  // Main API
  // ============================================================================

  /**
   * Calculate φ for a system state
   */
  calculate(system: SystemState): PhiResult {
    // Check cache
    if (this.config.cacheResults) {
      const cached = this.cache.get(system.stateHash);
      if (cached && Date.now() - cached.timestamp < this.config.cacheTTL) {
        return cached.result;
      }
    }

    const startTime = Date.now();

    let result: PhiResult;

    switch (this.config.approximationLevel) {
      case 'exact':
        result = this.calculateExact(system);
        break;
      case 'fast':
        result = this.calculateFast(system);
        break;
      case 'faster':
        result = this.calculateFaster(system);
        break;
      default:
        result = this.calculateFast(system);
    }

    result.calculationTime = Date.now() - startTime;

    // Cache result
    if (this.config.cacheResults) {
      this.cache.set(system.stateHash, { result, timestamp: Date.now() });
    }

    return result;
  }

  /**
   * Calculate φ for a specific subset of components
   */
  calculateSubset(system: SystemState, componentIds: string[]): PhiResult {
    const subset: SystemState = {
      ...system,
      components: system.components.filter((c) => componentIds.includes(c.id)),
      connections: system.connections.filter(
        (c) => componentIds.includes(c.from) && componentIds.includes(c.to)
      ),
      stateHash: `${system.stateHash}_subset_${componentIds.join(',')}`,
    };

    return this.calculate(subset);
  }

  /**
   * Find all complexes (subsystems with φ > 0)
   */
  findComplexes(system: SystemState): Complex[] {
    const complexes: Complex[] = [];

    // For each subset of components
    const componentIds = system.components.map((c) => c.id);
    const subsets = this.generateSubsets(componentIds, 2, Math.min(componentIds.length, 8));

    for (const subset of subsets) {
      const result = this.calculateSubset(system, subset);
      if (result.phi > 0) {
        complexes.push({
          elements: subset,
          phi: result.phi,
          mainComplex: false,
        });
      }
    }

    // Mark main complex (largest φ)
    if (complexes.length > 0) {
      complexes.sort((a, b) => b.phi - a.phi);
      complexes[0].mainComplex = true;
    }

    return complexes;
  }

  // ============================================================================
  // Calculation Methods
  // ============================================================================

  /**
   * Exact φ calculation (exponential complexity)
   * Only feasible for very small systems (< 10 components)
   */
  private calculateExact(system: SystemState): PhiResult {
    const componentIds = system.components.map((c) => c.id);

    if (componentIds.length > 12) {
      // Fall back to approximation for large systems
      return this.calculateFast(system);
    }

    // Generate all possible bipartitions
    const partitions = this.generateAllPartitions(componentIds);

    // Find MIP (Minimum Information Partition)
    let mip: Partition | null = null;
    let minIntegratedInfo = Infinity;

    for (const partition of partitions) {
      const integratedInfo = this.calculateIntegratedInformation(system, partition);
      if (integratedInfo < minIntegratedInfo) {
        minIntegratedInfo = integratedInfo;
        mip = partition;
      }
    }

    const intrinsicInfo = this.calculateIntrinsicInformation(system);

    return {
      phi: minIntegratedInfo,
      mip: mip || this.createTrivialPartition(componentIds),
      intrinsicInfo,
      integratedInfo: minIntegratedInfo,
      complexes: [],
      calculationTime: 0,
      approximation: false,
    };
  }

  /**
   * Fast approximation using greedy partitioning
   * O(n^2) complexity instead of O(2^n)
   */
  private calculateFast(system: SystemState): PhiResult {
    const componentIds = system.components.map((c) => c.id);

    // Use greedy algorithm to find approximate MIP
    const mip = this.greedyMIP(system, componentIds);

    // Calculate information measures
    const intrinsicInfo = this.calculateIntrinsicInformation(system);
    const integratedInfo = this.calculateIntegratedInformation(system, mip);

    return {
      phi: integratedInfo,
      mip,
      intrinsicInfo,
      integratedInfo,
      complexes: [],
      calculationTime: 0,
      approximation: true,
    };
  }

  /**
   * Faster approximation using heuristics
   * O(n) complexity
   */
  private calculateFaster(system: SystemState): PhiResult {
    // Use connection strength as proxy for integration
    const totalConnections = system.connections.length;
    const totalStrength = system.connections.reduce((sum, c) => sum + c.strength, 0);
    const avgStrength = totalConnections > 0 ? totalStrength / totalConnections : 0;

    // Use entropy as proxy for information
    const totalEntropy = system.components.reduce((sum, c) => sum + c.entropy, 0);
    const avgEntropy = system.components.length > 0 ? totalEntropy / system.components.length : 0;

    // Estimate φ from connectivity and entropy
    const connectionDensity = totalConnections / Math.max(1, system.components.length * (system.components.length - 1));
    const estimatedPhi = avgStrength * avgEntropy * connectionDensity;

    // Normalize to 0-1 range
    const normalizedPhi = Math.tanh(estimatedPhi);

    const componentIds = system.components.map((c) => c.id);

    return {
      phi: normalizedPhi,
      mip: this.createTrivialPartition(componentIds),
      intrinsicInfo: totalEntropy,
      integratedInfo: normalizedPhi,
      complexes: [],
      calculationTime: 0,
      approximation: true,
    };
  }

  // ============================================================================
  // Information Measures
  // ============================================================================

  /**
   * Calculate intrinsic information of the system
   * The information generated by the system about itself
   */
  private calculateIntrinsicInformation(system: SystemState): number {
    // Sum of component entropies
    let totalEntropy = 0;

    for (const component of system.components) {
      totalEntropy += component.entropy;
    }

    // Add mutual information from connections
    for (const connection of system.connections) {
      totalEntropy += connection.informationFlow * connection.strength;
    }

    return totalEntropy;
  }

  /**
   * Calculate integrated information for a partition
   * The information lost when the system is "cut" at the partition
   */
  private calculateIntegratedInformation(system: SystemState, partition: Partition): number {
    // Calculate information in whole system
    const wholeInfo = this.calculateIntrinsicInformation(system);

    // Calculate information in partitioned system
    let partitionedInfo = 0;

    for (const part of partition.parts) {
      const partSystem: SystemState = {
        ...system,
        components: system.components.filter((c) => part.includes(c.id)),
        connections: system.connections.filter(
          (c) => part.includes(c.from) && part.includes(c.to)
        ),
        stateHash: '',
        timestamp: new Date(),
      };
      partitionedInfo += this.calculateIntrinsicInformation(partSystem);
    }

    // φ is the information lost by partitioning
    return Math.max(0, wholeInfo - partitionedInfo);
  }

  // ============================================================================
  // Partition Generation
  // ============================================================================

  /**
   * Generate all bipartitions (exponential)
   */
  private generateAllPartitions(elements: string[]): Partition[] {
    const partitions: Partition[] = [];
    const n = elements.length;

    // Generate all possible ways to split into two non-empty sets
    // Using binary representation: 1 to 2^(n-1) - 1
    const limit = Math.pow(2, n - 1);

    for (let i = 1; i < limit; i++) {
      const part1: string[] = [];
      const part2: string[] = [];

      for (let j = 0; j < n; j++) {
        if ((i >> j) & 1) {
          part1.push(elements[j]);
        } else {
          part2.push(elements[j]);
        }
      }

      if (part1.length > 0 && part2.length > 0) {
        partitions.push(this.createPartition(elements, [part1, part2]));
      }

      // Limit for approximation
      if (partitions.length >= this.config.maxPartitions) {
        break;
      }
    }

    return partitions;
  }

  /**
   * Greedy MIP finding
   * Start with all elements together, greedily split to minimize φ
   */
  private greedyMIP(system: SystemState, elements: string[]): Partition {
    if (elements.length <= 1) {
      return this.createTrivialPartition(elements);
    }

    let bestPartition = this.createTrivialPartition(elements);
    let bestPhi = Infinity;

    // Try moving each element to a separate partition
    for (let i = 0; i < elements.length; i++) {
      const part1 = [elements[i]];
      const part2 = elements.filter((_, j) => j !== i);

      if (part2.length === 0) continue;

      const partition = this.createPartition(elements, [part1, part2]);
      const phi = this.calculateIntegratedInformation(system, partition);

      if (phi < bestPhi) {
        bestPhi = phi;
        bestPartition = partition;
      }
    }

    // Try pairwise splits
    for (let i = 0; i < elements.length; i++) {
      for (let j = i + 1; j < elements.length; j++) {
        const part1 = elements.slice(0, j);
        const part2 = elements.slice(j);

        if (part1.length === 0 || part2.length === 0) continue;

        const partition = this.createPartition(elements, [part1, part2]);
        const phi = this.calculateIntegratedInformation(system, partition);

        if (phi < bestPhi) {
          bestPhi = phi;
          bestPartition = partition;
        }
      }
    }

    return bestPartition;
  }

  /**
   * Generate subsets of a given size range
   */
  private generateSubsets(elements: string[], minSize: number, maxSize: number): string[][] {
    const subsets: string[][] = [];

    const generate = (start: number, current: string[]) => {
      if (current.length >= minSize && current.length <= maxSize) {
        subsets.push([...current]);
      }
      if (current.length >= maxSize) return;

      for (let i = start; i < elements.length; i++) {
        current.push(elements[i]);
        generate(i + 1, current);
        current.pop();
      }
    };

    generate(0, []);
    return subsets;
  }

  // ============================================================================
  // Helpers
  // ============================================================================

  private createPartition(elements: string[], parts: string[][]): Partition {
    const severedConnections: Cut['severedConnections'] = [];

    // Find connections that cross the partition
    for (let i = 0; i < parts.length; i++) {
      for (let j = i + 1; j < parts.length; j++) {
        for (const from of parts[i]) {
          for (const to of parts[j]) {
            severedConnections.push({ from, to });
          }
        }
      }
    }

    return {
      id: randomUUID(),
      parts,
      cut: {
        severedConnections,
        informationLoss: 0, // Calculated later
      },
    };
  }

  private createTrivialPartition(elements: string[]): Partition {
    return {
      id: randomUUID(),
      parts: [elements],
      cut: {
        severedConnections: [],
        informationLoss: 0,
      },
    };
  }

  // ============================================================================
  // Utility Methods
  // ============================================================================

  /**
   * Create a system state from component data
   */
  static createSystemState(
    components: Array<{
      id: string;
      type: string;
      active: boolean;
      state: Record<string, unknown>;
    }>,
    connections: Array<{
      from: string;
      to: string;
      strength: number;
    }>
  ): SystemState {
    const now = new Date();

    const componentStates: ComponentState[] = components.map((c) => ({
      ...c,
      entropy: PhiCalculator.estimateEntropy(c.state),
      lastUpdate: now,
    }));

    const connectionStates: Connection[] = connections.map((c) => ({
      ...c,
      informationFlow: c.strength, // Simplified
      bidirectional: false,
    }));

    // Create state hash
    const stateHash = PhiCalculator.hashState(componentStates);

    return {
      components: componentStates,
      connections: connectionStates,
      stateHash,
      timestamp: now,
    };
  }

  /**
   * Estimate entropy of a state object
   */
  static estimateEntropy(state: Record<string, unknown>): number {
    // Simplified entropy estimation based on state complexity
    const stateString = JSON.stringify(state);
    const uniqueChars = new Set(stateString).size;
    const length = stateString.length;

    // Shannon entropy approximation
    if (length === 0) return 0;
    return Math.log2(uniqueChars) * (length / 100);
  }

  /**
   * Create a hash of the system state
   */
  static hashState(components: ComponentState[]): string {
    const stateString = components
      .map((c) => `${c.id}:${c.active}:${JSON.stringify(c.state)}`)
      .sort()
      .join('|');

    // Simple hash function
    let hash = 0;
    for (let i = 0; i < stateString.length; i++) {
      const char = stateString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }

  /**
   * Clear the calculation cache
   */
  clearCache(): void {
    this.cache.clear();
  }
}

// ============================================================================
// Factory
// ============================================================================

export function createPhiCalculator(config?: Partial<PhiCalculatorConfig>): PhiCalculator {
  return new PhiCalculator(config);
}
