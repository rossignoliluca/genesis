/**
 * Economic Fiber Bundle — Per-Module Cost/Revenue Tracking
 *
 * The economy is a fiber bundle over the module base space:
 *   π: E → B
 *   Base space B = {kernel, inference, effects, memory, consciousness, ...}
 *   Fiber F = (balance, costRate, revenueRate, roi)
 *
 * Each module carries an economic fiber that tracks its costs and revenues.
 * The global section Γ(E) exists IFF the system is economically sustainable.
 *
 * This replaces the simple BudgetManager with per-module attribution,
 * enabling the FEK's L4 to compute ROI and reallocate resources.
 */

export interface ModuleFiber {
  moduleId: string;
  balance: number;          // Budget allocated to this module
  costRate: number;         // $/cycle spent by this module
  revenueRate: number;      // $/cycle generated (0 for internal modules)
  totalSpent: number;       // Lifetime costs
  totalEarned: number;      // Lifetime revenue
  roi: number;              // (earned - spent) / spent, or 0 if spent = 0
  operationsCount: number;  // Number of operations performed
  lastUpdate: number;       // Timestamp of last update
}

export interface CostRecord {
  moduleId: string;
  amount: number;
  operation: string;
  timestamp: number;
}

export interface RevenueRecord {
  source: string;
  amount: number;
  timestamp: number;
}

export interface GlobalSection {
  totalRevenue: number;
  totalCosts: number;
  netFlow: number;          // revenue - costs (≥ 0 for β-closure)
  runway: number;           // days of operation remaining
  burnRate: number;         // $/day
  sustainable: boolean;     // netFlow ≥ 0
  moduleCount: number;
}

/**
 * Economic Fiber Bundle: tracks per-module economics.
 */
export class EconomicFiber {
  private fibers: Map<string, ModuleFiber> = new Map();
  private costLog: CostRecord[] = [];
  private revenueLog: RevenueRecord[] = [];
  private totalBudget: number;
  private readonly maxLogSize: number = 1000;

  constructor(totalBudget: number = 100) {
    this.totalBudget = totalBudget;
  }

  /**
   * Register a module in the fiber bundle.
   */
  registerModule(moduleId: string, initialBalance?: number): void {
    if (this.fibers.has(moduleId)) return;
    this.fibers.set(moduleId, {
      moduleId,
      balance: initialBalance ?? (this.totalBudget / Math.max(this.fibers.size + 1, 1)),
      costRate: 0,
      revenueRate: 0,
      totalSpent: 0,
      totalEarned: 0,
      roi: 0,
      operationsCount: 0,
      lastUpdate: Date.now(),
    });
  }

  /**
   * Record a cost incurred by a module.
   */
  recordCost(moduleId: string, amount: number, operation: string = 'unknown'): void {
    const fiber = this.fibers.get(moduleId);
    if (!fiber) {
      this.registerModule(moduleId);
      return this.recordCost(moduleId, amount, operation);
    }

    fiber.balance -= amount;
    fiber.totalSpent += amount;
    fiber.operationsCount++;
    fiber.lastUpdate = Date.now();
    this.updateROI(fiber);
    this.updateCostRate(fiber);

    this.costLog.push({ moduleId, amount, operation, timestamp: Date.now() });
    if (this.costLog.length > this.maxLogSize) {
      this.costLog = this.costLog.slice(-this.maxLogSize);
    }
  }

  /**
   * Record revenue generated by a module (or attributed to it).
   */
  recordRevenue(moduleId: string, amount: number, source: string = 'service'): void {
    const fiber = this.fibers.get(moduleId);
    if (!fiber) {
      this.registerModule(moduleId);
      return this.recordRevenue(moduleId, amount, source);
    }

    fiber.balance += amount;
    fiber.totalEarned += amount;
    fiber.lastUpdate = Date.now();
    this.updateROI(fiber);
    this.updateRevenueRate(fiber);

    this.revenueLog.push({ source: `${moduleId}:${source}`, amount, timestamp: Date.now() });
    if (this.revenueLog.length > this.maxLogSize) {
      this.revenueLog = this.revenueLog.slice(-this.maxLogSize);
    }
  }

  /**
   * Reallocate budget between modules based on ROI.
   * Returns the new allocations (for leapfrog integrator input).
   */
  getAllocations(): number[] {
    const modules = [...this.fibers.values()];
    return modules.map(m => m.balance);
  }

  /**
   * Set allocations from leapfrog output (symplectic update).
   */
  setAllocations(allocations: number[]): void {
    const modules = [...this.fibers.values()];
    for (let i = 0; i < Math.min(modules.length, allocations.length); i++) {
      modules[i].balance = allocations[i];
      modules[i].lastUpdate = Date.now();
    }
  }

  /**
   * Get ROI per module (for leapfrog gradient).
   */
  getROIs(): number[] {
    return [...this.fibers.values()].map(m => m.roi);
  }

  /**
   * Get the global economic section.
   * Γ(E) exists IFF sustainable = true.
   */
  getGlobalSection(): GlobalSection {
    const modules = [...this.fibers.values()];
    const totalRevenue = modules.reduce((s, m) => s + m.totalEarned, 0);
    const totalCosts = modules.reduce((s, m) => s + m.totalSpent, 0);
    const netFlow = totalRevenue - totalCosts;

    // Burn rate: total cost rate across all modules
    const burnRate = modules.reduce((s, m) => s + m.costRate, 0) * 86400; // per day
    const currentBalance = modules.reduce((s, m) => s + m.balance, 0);
    const runway = burnRate > 0 ? currentBalance / burnRate : Infinity;

    return {
      totalRevenue,
      totalCosts,
      netFlow,
      runway: Math.min(runway, 36500), // Cap at 100 years
      burnRate,
      sustainable: netFlow >= 0,
      moduleCount: modules.length,
    };
  }

  /**
   * Get fiber for a specific module.
   */
  getFiber(moduleId: string): ModuleFiber | undefined {
    return this.fibers.get(moduleId);
  }

  /**
   * Get all fibers.
   */
  getAllFibers(): ModuleFiber[] {
    return [...this.fibers.values()];
  }

  /**
   * Get module IDs sorted by ROI (highest first).
   */
  getModulesByROI(): string[] {
    return [...this.fibers.values()]
      .sort((a, b) => b.roi - a.roi)
      .map(m => m.moduleId);
  }

  /**
   * Total budget accessor.
   */
  getTotalBudget(): number {
    return this.totalBudget;
  }

  setTotalBudget(budget: number): void {
    this.totalBudget = budget;
  }

  /**
   * Recent cost log.
   */
  getRecentCosts(limit: number = 20): CostRecord[] {
    return this.costLog.slice(-limit);
  }

  /**
   * Recent revenue log.
   */
  getRecentRevenue(limit: number = 20): RevenueRecord[] {
    return this.revenueLog.slice(-limit);
  }

  // ============================================================================
  // Private helpers
  // ============================================================================

  private updateROI(fiber: ModuleFiber): void {
    fiber.roi = fiber.totalSpent > 0
      ? (fiber.totalEarned - fiber.totalSpent) / fiber.totalSpent
      : 0;
  }

  private updateCostRate(fiber: ModuleFiber): void {
    // Simple: average cost per operation, scaled by operations per second
    const recentCosts = this.costLog
      .filter(c => c.moduleId === fiber.moduleId && Date.now() - c.timestamp < 60000);
    fiber.costRate = recentCosts.length > 0
      ? recentCosts.reduce((s, c) => s + c.amount, 0) / 60 // per second
      : 0;
  }

  private updateRevenueRate(fiber: ModuleFiber): void {
    const recentRevenue = this.revenueLog
      .filter(r => r.source.startsWith(fiber.moduleId) && Date.now() - r.timestamp < 60000);
    fiber.revenueRate = recentRevenue.length > 0
      ? recentRevenue.reduce((s, r) => s + r.amount, 0) / 60
      : 0;
  }
}

// ============================================================================
// Singleton
// ============================================================================

let fiberInstance: EconomicFiber | null = null;

export function getEconomicFiber(totalBudget?: number): EconomicFiber {
  if (!fiberInstance) {
    fiberInstance = new EconomicFiber(totalBudget);
  }
  return fiberInstance;
}

export function resetEconomicFiber(): void {
  fiberInstance = null;
}
