/**
 * Genesis RSI - DEPLOY Subsystem
 *
 * Deploys verified implementations through:
 * - Git branch creation
 * - Commit with detailed message
 * - Pull request creation
 * - Review workflow (self-review or human review)
 * - Merge execution
 *
 * @module rsi/deploy
 */

import { execSync } from 'child_process';
import * as path from 'path';
import {
  ImprovementPlan, ImplementationResult, DeploymentResult,
  ReviewStatus, MergeStatus, RSIConfig
} from '../types.js';
import { getMCPClient } from '../../mcp/index.js';
import { getObservationEngine } from '../observe/index.js';

// =============================================================================
// GIT MANAGER
// =============================================================================

export class GitManager {
  private cwd: string;

  constructor(cwd?: string) {
    this.cwd = cwd || process.cwd();
  }

  /**
   * Create a new branch for the improvement
   */
  createBranch(planId: string): string {
    const branchName = `rsi/improvement-${planId.slice(0, 8)}`;

    try {
      // Ensure we're on a clean state
      execSync('git stash', { cwd: this.cwd, stdio: 'pipe' });
    } catch (e) { console.debug('[RSI Git] No changes to stash:', (e as Error)?.message); }

    try {
      // Create and checkout new branch
      execSync(`git checkout -b ${branchName}`, {
        cwd: this.cwd,
        stdio: 'pipe',
      });

      return branchName;
    } catch (error: any) {
      // Branch might already exist
      if (error.message?.includes('already exists')) {
        execSync(`git checkout ${branchName}`, { cwd: this.cwd, stdio: 'pipe' });
        return branchName;
      }
      throw error;
    }
  }

  /**
   * Stage and commit changes
   */
  commit(
    plan: ImprovementPlan,
    implementation: ImplementationResult
  ): string {
    // Stage all changes
    execSync('git add -A', { cwd: this.cwd, stdio: 'pipe' });

    // Build commit message
    const message = this.buildCommitMessage(plan, implementation);

    // Commit using heredoc for multiline message
    const escapedMessage = message.replace(/'/g, "'\\''");
    execSync(`git commit -m '${escapedMessage}'`, {
      cwd: this.cwd,
      stdio: 'pipe',
    });

    // Get commit hash
    const hash = execSync('git rev-parse HEAD', {
      cwd: this.cwd,
      encoding: 'utf-8',
    }).trim();

    return hash;
  }

  private buildCommitMessage(
    plan: ImprovementPlan,
    implementation: ImplementationResult
  ): string {
    const parts: string[] = [];

    // Title
    parts.push(`[RSI] ${plan.name}`);
    parts.push('');

    // Description
    parts.push(plan.description);
    parts.push('');

    // Changes
    parts.push('Changes:');
    for (const change of plan.changes) {
      parts.push(`- ${change.type}: ${change.file}`);
    }
    parts.push('');

    // Safety
    parts.push(`Safety: ${plan.safetyAnalysis.riskLevel} risk`);
    if (plan.safetyAnalysis.mitigations.length > 0) {
      parts.push(`Mitigations: ${plan.safetyAnalysis.mitigations.slice(0, 2).join(', ')}`);
    }
    parts.push('');

    // Constitutional
    parts.push(`Constitutional: ${plan.constitutionalApproval.approved ? 'APPROVED' : 'REVIEW NEEDED'}`);
    parts.push('');

    // Results
    parts.push('Implementation Results:');
    parts.push(`- Build: ${implementation.buildResult.success ? 'PASS' : 'FAIL'}`);
    parts.push(`- Tests: ${implementation.testResult.passed} passed, ${implementation.testResult.failed} failed`);
    parts.push(`- Invariants: ${implementation.invariantResult.allPassed ? 'ALL PASS' : 'VIOLATIONS'}`);
    parts.push('');

    // Footer
    parts.push('---');
    parts.push('ü§ñ Generated by Genesis RSI (Recursive Self-Improvement)');
    parts.push(`Plan ID: ${plan.id}`);

    return parts.join('\n');
  }

  /**
   * Push branch to remote
   */
  push(branchName: string): void {
    execSync(`git push -u origin ${branchName}`, {
      cwd: this.cwd,
      stdio: 'pipe',
    });
  }

  /**
   * Revert a commit
   */
  revert(commitHash: string): void {
    execSync(`git revert --no-commit ${commitHash}`, {
      cwd: this.cwd,
      stdio: 'pipe',
    });
    execSync(`git commit -m "Revert RSI improvement: ${commitHash}"`, {
      cwd: this.cwd,
      stdio: 'pipe',
    });
  }

  /**
   * Return to main branch
   */
  returnToMain(): void {
    try {
      execSync('git checkout main', { cwd: this.cwd, stdio: 'pipe' });
    } catch (e) {
      console.debug('[RSI Git] Main checkout failed, trying master:', (e as Error)?.message);
      try {
        execSync('git checkout master', { cwd: this.cwd, stdio: 'pipe' });
      } catch (e2) { console.debug('[RSI Git] Master checkout also failed:', (e2 as Error)?.message); }
    }
  }

  /**
   * Get current branch name
   */
  getCurrentBranch(): string {
    return execSync('git rev-parse --abbrev-ref HEAD', {
      cwd: this.cwd,
      encoding: 'utf-8',
    }).trim();
  }

  /**
   * Check if there are uncommitted changes
   */
  hasUncommittedChanges(): boolean {
    const status = execSync('git status --porcelain', {
      cwd: this.cwd,
      encoding: 'utf-8',
    }).trim();
    return status.length > 0;
  }
}

// =============================================================================
// PR MANAGER
// =============================================================================

export class PRManager {
  private mcp = getMCPClient();
  private gitManager: GitManager;

  constructor(gitManager: GitManager) {
    this.gitManager = gitManager;
  }

  /**
   * Create a pull request for the improvement
   */
  async createPR(
    plan: ImprovementPlan,
    implementation: ImplementationResult,
    branchName: string
  ): Promise<{ prUrl: string; prNumber: number } | null> {
    try {
      const title = `[RSI] ${plan.name}`;
      const body = this.buildPRBody(plan, implementation);

      const result = await this.mcp.call('github', 'create_pull_request', {
        owner: await this.getRepoOwner(),
        repo: await this.getRepoName(),
        title,
        body,
        head: branchName,
        base: 'main',
      }) as any;

      if (result && result.html_url) {
        return {
          prUrl: result.html_url,
          prNumber: result.number,
        };
      }
    } catch (error) {
      console.error(`[RSI Deploy] Failed to create PR: ${error}`);
    }

    return null;
  }

  private buildPRBody(
    plan: ImprovementPlan,
    implementation: ImplementationResult
  ): string {
    const parts: string[] = [];

    parts.push('## Summary');
    parts.push(plan.description);
    parts.push('');

    // Target
    if (plan.targetLimitation) {
      parts.push('### Addressing Limitation');
      parts.push(`- Type: ${plan.targetLimitation.type}`);
      parts.push(`- Severity: ${plan.targetLimitation.severity}`);
      parts.push(`- Description: ${plan.targetLimitation.description}`);
      parts.push('');
    }

    // Changes
    parts.push('### Changes');
    for (const change of plan.changes) {
      const status = implementation.changes.find(c => c.changeId === change.id);
      const emoji = status?.applied ? '‚úÖ' : '‚ùå';
      parts.push(`- ${emoji} \`${change.file}\`: ${change.description}`);
    }
    parts.push('');

    // Safety Analysis
    parts.push('### Safety Analysis');
    parts.push(`- **Risk Level**: ${plan.safetyAnalysis.riskLevel}`);
    parts.push(`- **Passed**: ${plan.safetyAnalysis.passed ? 'Yes' : 'No'}`);
    if (plan.safetyAnalysis.sideEffects.length > 0) {
      parts.push('- **Side Effects**:');
      for (const effect of plan.safetyAnalysis.sideEffects) {
        parts.push(`  - ${effect}`);
      }
    }
    parts.push('');

    // Constitutional Review
    parts.push('### Constitutional Review');
    parts.push(`- **Approved**: ${plan.constitutionalApproval.approved ? '‚úÖ Yes' : '‚ùå No'}`);
    for (const principle of plan.constitutionalApproval.principles) {
      const emoji = principle.satisfied ? '‚úÖ' : '‚ùå';
      parts.push(`- ${emoji} ${principle.description}`);
    }
    if (plan.constitutionalApproval.critique) {
      parts.push('');
      parts.push('**Critique**:');
      parts.push(plan.constitutionalApproval.critique);
    }
    parts.push('');

    // Test Results
    parts.push('### Test Results');
    parts.push(`- Build: ${implementation.buildResult.success ? '‚úÖ Pass' : '‚ùå Fail'}`);
    parts.push(`- Tests: ${implementation.testResult.passed} passed, ${implementation.testResult.failed} failed`);
    parts.push(`- Invariants: ${implementation.invariantResult.allPassed ? '‚úÖ All Pass' : '‚ùå Violations'}`);
    parts.push('');

    // Rollback
    parts.push('### Rollback Strategy');
    parts.push(`Type: ${plan.rollbackStrategy.type}`);
    parts.push('```bash');
    for (const step of plan.rollbackStrategy.rollbackSteps.slice(0, 4)) {
      parts.push(step);
    }
    parts.push('```');
    parts.push('');

    // Footer
    parts.push('---');
    parts.push('ü§ñ Generated by Genesis RSI (Recursive Self-Improvement)');
    parts.push(`Plan ID: \`${plan.id}\``);

    return parts.join('\n');
  }

  private async getRepoOwner(): Promise<string> {
    try {
      const remote = execSync('git remote get-url origin', {
        cwd: process.cwd(),
        encoding: 'utf-8',
      }).trim();

      // Parse GitHub URL
      const match = remote.match(/github\.com[:/]([^/]+)\//);
      if (match) {
        return match[1];
      }
    } catch (e) { console.debug('[RSI Deploy] Owner lookup failed:', (e as Error)?.message); }

    return 'lucarossignoli'; // Default fallback
  }

  private async getRepoName(): Promise<string> {
    try {
      const remote = execSync('git remote get-url origin', {
        cwd: process.cwd(),
        encoding: 'utf-8',
      }).trim();

      // Parse GitHub URL
      const match = remote.match(/github\.com[:/][^/]+\/([^/.]+)/);
      if (match) {
        return match[1];
      }
    } catch (e) { console.debug('[RSI Deploy] Repo lookup failed:', (e as Error)?.message); }

    return 'genesis'; // Default fallback
  }

  /**
   * Merge a pull request
   */
  async mergePR(prNumber: number): Promise<boolean> {
    try {
      await this.mcp.call('github', 'merge_pull_request', {
        owner: await this.getRepoOwner(),
        repo: await this.getRepoName(),
        pull_number: prNumber,
        merge_method: 'squash',
      });
      return true;
    } catch (error) {
      console.error(`[RSI Deploy] Failed to merge PR: ${error}`);
      return false;
    }
  }
}

// =============================================================================
// REVIEW MANAGER
// =============================================================================

export class ReviewManager {
  private config: Partial<RSIConfig>;

  constructor(config: Partial<RSIConfig> = {}) {
    this.config = config;
  }

  /**
   * Determine review status based on plan and config
   */
  determineReviewStatus(plan: ImprovementPlan): ReviewStatus {
    // Always require human review if configured
    if (this.config.requireHumanReview) {
      return 'human-review-requested';
    }

    // Check risk threshold
    const riskLevels = ['low', 'medium', 'high', 'critical'];
    const threshold = this.config.humanReviewThreshold || 'high';
    const thresholdIdx = riskLevels.indexOf(threshold);
    const riskIdx = riskLevels.indexOf(plan.safetyAnalysis.riskLevel);

    if (riskIdx >= thresholdIdx) {
      return 'human-review-requested';
    }

    // Check constitutional approval
    if (!plan.constitutionalApproval.approved) {
      return 'human-review-requested';
    }

    // Auto-approve for low risk, constitutionally approved plans
    return 'auto-approved';
  }

  /**
   * Perform self-review (for low-risk changes)
   */
  performSelfReview(plan: ImprovementPlan, implementation: ImplementationResult): ReviewStatus {
    // Verify all checks passed
    if (!implementation.success) {
      return 'pending';
    }

    if (!plan.constitutionalApproval.approved) {
      return 'pending';
    }

    if (plan.safetyAnalysis.riskLevel === 'high' || plan.safetyAnalysis.riskLevel === 'critical') {
      return 'human-review-requested';
    }

    return 'self-reviewed';
  }
}

// =============================================================================
// DEPLOYMENT ENGINE
// =============================================================================

export class DeploymentEngine {
  private gitManager: GitManager;
  private prManager: PRManager;
  private reviewManager: ReviewManager;
  private config: Partial<RSIConfig>;

  constructor(config: Partial<RSIConfig> = {}) {
    this.config = config;
    this.gitManager = new GitManager();
    this.prManager = new PRManager(this.gitManager);
    this.reviewManager = new ReviewManager(config);
  }

  /**
   * Deploy a successful implementation
   */
  async deploy(
    plan: ImprovementPlan,
    implementation: ImplementationResult
  ): Promise<DeploymentResult> {
    if (!implementation.success) {
      return {
        planId: plan.id,
        success: false,
        branchName: '',
        commitHash: '',
        reviewStatus: 'pending',
        mergeStatus: 'blocked',
        error: 'Cannot deploy failed implementation',
      };
    }

    console.log(`[RSI Deploy] Starting deployment of plan: ${plan.id}`);

    let branchName = '';
    let commitHash = '';

    try {
      // 1. Create branch
      branchName = this.gitManager.createBranch(plan.id);
      console.log(`[RSI Deploy] Created branch: ${branchName}`);

      // 2. Commit changes
      commitHash = this.gitManager.commit(plan, implementation);
      console.log(`[RSI Deploy] Committed: ${commitHash}`);

      // 3. Push to remote
      try {
        this.gitManager.push(branchName);
        console.log(`[RSI Deploy] Pushed to remote`);
      } catch (error) {
        console.error(`[RSI Deploy] Push failed (may not have remote): ${error}`);
      }

      // 4. Determine review status
      const reviewStatus = this.reviewManager.determineReviewStatus(plan);
      console.log(`[RSI Deploy] Review status: ${reviewStatus}`);

      // 5. Create PR if review needed
      let prUrl: string | undefined;
      let prNumber: number | undefined;

      if (reviewStatus === 'human-review-requested') {
        const pr = await this.prManager.createPR(plan, implementation, branchName);
        if (pr) {
          prUrl = pr.prUrl;
          prNumber = pr.prNumber;
          console.log(`[RSI Deploy] Created PR: ${prUrl}`);
        }

        return {
          planId: plan.id,
          success: true,
          branchName,
          commitHash,
          prUrl,
          prNumber,
          reviewStatus,
          mergeStatus: 'pending',
        };
      }

      // 6. Auto-merge for self-reviewed changes
      if (reviewStatus === 'auto-approved' || reviewStatus === 'self-reviewed') {
        // For auto-approved, we can merge directly to main
        try {
          this.gitManager.returnToMain();
          execSync(`git merge ${branchName}`, {
            cwd: process.cwd(),
            stdio: 'pipe',
          });
          execSync('git push', {
            cwd: process.cwd(),
            stdio: 'pipe',
          });

          // v15.0: Register new capabilities from successfully deployed changes
          this.registerDeployedCapabilities(plan);

          return {
            planId: plan.id,
            success: true,
            branchName,
            commitHash,
            reviewStatus,
            mergeStatus: 'merged',
            deployedAt: new Date(),
          };
        } catch (error) {
          console.error(`[RSI Deploy] Auto-merge failed: ${error}`);
          return {
            planId: plan.id,
            success: true,
            branchName,
            commitHash,
            reviewStatus,
            mergeStatus: 'merge-conflict',
            error: `Auto-merge failed: ${error}`,
          };
        }
      }

      return {
        planId: plan.id,
        success: true,
        branchName,
        commitHash,
        reviewStatus,
        mergeStatus: 'pending',
      };

    } catch (error) {
      // Attempt to return to main branch
      try {
        this.gitManager.returnToMain();
      } catch (e) { console.debug('[RSI Deploy] Cleanup failed:', (e as Error)?.message); }

      return {
        planId: plan.id,
        success: false,
        branchName,
        commitHash,
        reviewStatus: 'pending',
        mergeStatus: 'blocked',
        error: `Deployment failed: ${error}`,
      };
    }
  }

  /**
   * Register capabilities from successfully deployed plan (v15.0)
   * This prevents RSI from repeatedly identifying the same capability gaps
   */
  private registerDeployedCapabilities(plan: ImprovementPlan): void {
    try {
      const observeEngine = getObservationEngine();
      const capabilityDetector = observeEngine.getCapabilityDetector();

      // Extract capability names from created files
      for (const change of plan.changes) {
        if (change.type === 'create') {
          // Extract capability from file path
          // e.g., src/agents/image-processor.ts ‚Üí image-processor
          const match = change.file.match(/([a-z-]+)\.ts$/i);
          if (match) {
            const capabilityName = match[1];
            capabilityDetector.registerCapability(capabilityName);
            console.log(`[RSI Deploy] Registered capability: ${capabilityName}`);
          }
        }
      }

      // Also register from plan description keywords
      if (plan.targetLimitation?.type === 'capability') {
        const desc = plan.targetLimitation.description.toLowerCase();
        const knownCapabilities = [
          'code-generation', 'self-modification', 'web-scraping',
          'financial-analysis', 'image-understanding', 'multi-modal',
          'natural-language', 'reasoning', 'planning',
        ];
        for (const cap of knownCapabilities) {
          if (desc.includes(cap.replace('-', ' ')) || desc.includes(cap)) {
            capabilityDetector.registerCapability(cap);
            console.log(`[RSI Deploy] Registered capability from limitation: ${cap}`);
          }
        }
      }
    } catch (error) {
      console.error(`[RSI Deploy] Failed to register capabilities: ${error}`);
    }
  }

  /**
   * Rollback a deployment
   */
  async rollback(deployment: DeploymentResult): Promise<boolean> {
    if (!deployment.commitHash) {
      return false;
    }

    try {
      this.gitManager.returnToMain();
      this.gitManager.revert(deployment.commitHash);
      return true;
    } catch (error) {
      console.error(`[RSI Deploy] Rollback failed: ${error}`);
      return false;
    }
  }
}

// =============================================================================
// SINGLETON
// =============================================================================

let deploymentEngineInstance: DeploymentEngine | null = null;

export function getDeploymentEngine(config?: Partial<RSIConfig>): DeploymentEngine {
  if (!deploymentEngineInstance) {
    deploymentEngineInstance = new DeploymentEngine(config);
  }
  return deploymentEngineInstance;
}

export function resetDeploymentEngine(): void {
  deploymentEngineInstance = null;
}
