/**
 * Semiotics Module - Large Semiosis Model (LSM)
 *
 * Implements Peircean semiotics for grounded AI reasoning:
 * - Triadic sign interpretation (Representamen-Object-Interpretant)
 * - Abductive reasoning for hypothesis generation
 * - Hallucination detection via semiotic grounding
 * - Meta-semiosis (signs about signs)
 *
 * Based on:
 * - C.S. Peirce's semiotic theory
 * - Biosemiotics (Hoffmeyer, Kull)
 * - Computational semiotics
 */

import { EventEmitter } from 'events';

// ============================================================================
// Types
// ============================================================================

export type SignType =
  | 'icon'        // Resembles its object (image, diagram)
  | 'index'       // Causally connected to object (smoke->fire)
  | 'symbol';     // Conventional relation (word->meaning)

export type InterpretantType =
  | 'immediate'   // First impression, potential meaning
  | 'dynamic'     // Actual effect on interpreter
  | 'final';      // Ultimate meaning if fully understood

export interface Sign {
  id: string;
  representamen: string;      // The sign vehicle (token, symbol, image)
  type: SignType;
  context?: string;
  timestamp: number;
}

export interface Object {
  id: string;
  referent: unknown;          // What the sign refers to
  groundingType: 'direct' | 'indirect' | 'abstract' | 'fictional';
  confidence: number;
  source?: string;
}

export interface Interpretant {
  id: string;
  type: InterpretantType;
  meaning: string;
  effect: 'emotional' | 'energetic' | 'logical';
  furtherSigns: string[];     // Signs generated by interpretation
}

export interface Triad {
  sign: Sign;
  object: Object | null;
  interpretant: Interpretant;
  coherence: number;          // How well the triad holds together
  grounded: boolean;          // Whether object exists in world model
}

export interface HallucinationRisk {
  level: 'none' | 'low' | 'medium' | 'high' | 'certain';
  score: number;              // 0-1
  reasons: string[];
  mitigations?: string[];
}

export interface AbductiveHypothesis {
  hypothesis: string;
  evidence: Sign[];
  plausibility: number;
  testability: number;
  implications: string[];
}

export interface SemioticConfig {
  // Grounding requirements
  minGroundingConfidence: number;
  requireDirectGrounding: boolean;

  // Interpretation settings
  maxInterpretationDepth: number;
  allowMetaSemiosis: boolean;

  // Hallucination detection
  hallucinationThreshold: number;
  strictMode: boolean;
}

export interface WorldModel {
  lookup(claim: string): Object | null;
  verify(object: Object): boolean;
  getRelated(object: Object): Object[];
}

export interface SemioticMetrics {
  signsProcessed: number;
  triadsFormed: number;
  groundedTriads: number;
  hallucinationsDetected: number;
  abductionsPerformed: number;
  metaSignsGenerated: number;
}

// ============================================================================
// Default Configuration
// ============================================================================

const DEFAULT_CONFIG: SemioticConfig = {
  minGroundingConfidence: 0.7,
  requireDirectGrounding: false,
  maxInterpretationDepth: 5,
  allowMetaSemiosis: true,
  hallucinationThreshold: 0.5,
  strictMode: false
};

// ============================================================================
// Large Semiosis Model
// ============================================================================

export class LargeSemiosisModel extends EventEmitter {
  private config: SemioticConfig;
  private worldModel: WorldModel | null;
  private triads: Map<string, Triad>;
  private signHistory: Sign[];
  private metrics: SemioticMetrics;

  constructor(config: Partial<SemioticConfig> = {}, worldModel?: WorldModel) {
    super();
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.worldModel = worldModel || null;
    this.triads = new Map();
    this.signHistory = [];
    this.metrics = {
      signsProcessed: 0,
      triadsFormed: 0,
      groundedTriads: 0,
      hallucinationsDetected: 0,
      abductionsPerformed: 0,
      metaSignsGenerated: 0
    };
  }

  /**
   * Set the world model for grounding
   */
  setWorldModel(worldModel: WorldModel): void {
    this.worldModel = worldModel;
  }

  /**
   * Interpret a sign using triadic semiosis
   * Returns the full Sign-Object-Interpretant triad
   */
  interpret(sign: Sign): Triad {
    this.metrics.signsProcessed++;
    this.signHistory.push(sign);
    if (this.signHistory.length > 200) {
      this.signHistory = this.signHistory.slice(-100);
    }

    // Step 1: Find the object (ground the sign)
    const object = this.groundSign(sign);

    // Step 2: Generate interpretant
    const interpretant = this.generateInterpretant(sign, object);

    // Step 3: Assess coherence
    const coherence = this.assessCoherence(sign, object, interpretant);

    const triad: Triad = {
      sign,
      object,
      interpretant,
      coherence,
      grounded: object !== null && object.confidence >= this.config.minGroundingConfidence
    };

    this.triads.set(sign.id, triad);
    if (this.triads.size > 500) {
      const keys = Array.from(this.triads.keys());
      for (let i = 0; i < 100; i++) this.triads.delete(keys[i]);
    }
    this.metrics.triadsFormed++;

    if (triad.grounded) {
      this.metrics.groundedTriads++;
    }

    this.emit('triad:formed', triad);
    return triad;
  }

  /**
   * Ground a sign in the world model
   */
  private groundSign(sign: Sign): Object | null {
    if (!this.worldModel) {
      // No world model - create abstract object
      return {
        id: `obj-${sign.id}`,
        referent: sign.representamen,
        groundingType: 'abstract',
        confidence: 0.3,
        source: 'no-world-model'
      };
    }

    // Query world model
    const object = this.worldModel.lookup(sign.representamen);

    if (!object) {
      return null;
    }

    // Verify object exists
    if (!this.worldModel.verify(object)) {
      return {
        ...object,
        groundingType: 'indirect',
        confidence: object.confidence * 0.5
      };
    }

    return object;
  }

  /**
   * Generate an interpretant for a sign
   */
  private generateInterpretant(sign: Sign, object: Object | null): Interpretant {
    const id = `int-${sign.id}`;

    // Determine effect type based on sign type
    let effect: 'emotional' | 'energetic' | 'logical';
    switch (sign.type) {
      case 'icon':
        effect = 'emotional';  // Icons evoke feelings
        break;
      case 'index':
        effect = 'energetic';  // Indices prompt action
        break;
      case 'symbol':
        effect = 'logical';    // Symbols require reasoning
        break;
    }

    // Generate meaning
    let meaning: string;
    if (object) {
      meaning = `Sign "${sign.representamen}" refers to ${JSON.stringify(object.referent)}`;
    } else {
      meaning = `Sign "${sign.representamen}" has no grounded referent`;
    }

    // Determine interpretant type
    const type: InterpretantType = object?.confidence && object.confidence > 0.8
      ? 'final'
      : object
        ? 'dynamic'
        : 'immediate';

    return {
      id,
      type,
      meaning,
      effect,
      furtherSigns: []  // Will be populated in meta-semiosis
    };
  }

  /**
   * Assess coherence of a triad
   */
  private assessCoherence(sign: Sign, object: Object | null, interpretant: Interpretant): number {
    let coherence = 0.5;  // Base coherence

    // Object grounding improves coherence
    if (object) {
      coherence += object.confidence * 0.3;
    }

    // Sign type alignment
    if (object?.groundingType === 'direct' && sign.type === 'index') {
      coherence += 0.1;  // Indices with direct objects are strong
    }
    if (object?.groundingType === 'abstract' && sign.type === 'symbol') {
      coherence += 0.05;  // Symbols can have abstract objects
    }

    // Interpretant type alignment
    if (interpretant.type === 'final' && object?.confidence && object.confidence > 0.9) {
      coherence += 0.1;
    }

    return Math.min(1, coherence);
  }

  /**
   * Detect potential hallucination in a claim
   */
  detectHallucination(claim: string): HallucinationRisk {
    const sign: Sign = {
      id: `claim-${Date.now()}`,
      representamen: claim,
      type: 'symbol',
      timestamp: Date.now()
    };

    const triad = this.interpret(sign);
    const reasons: string[] = [];
    let score = 0;

    // Check grounding
    if (!triad.grounded) {
      score += 0.4;
      reasons.push('No grounding in world model');
    }

    // Check object existence
    if (!triad.object) {
      score += 0.3;
      reasons.push('No object referent found');
    } else if (triad.object.groundingType === 'fictional') {
      score += 0.2;
      reasons.push('Object is fictional');
    } else if (triad.object.confidence < 0.5) {
      score += 0.2;
      reasons.push('Low object confidence');
    }

    // Check coherence
    if (triad.coherence < 0.5) {
      score += 0.2;
      reasons.push('Low triadic coherence');
    }

    // Check for internal contradictions
    const contradictions = this.findContradictions(claim);
    if (contradictions.length > 0) {
      score += 0.2;
      reasons.push(...contradictions.map(c => `Contradiction: ${c}`));
    }

    score = Math.min(1, score);

    if (score > this.config.hallucinationThreshold) {
      this.metrics.hallucinationsDetected++;
    }

    const level = this.scoreToLevel(score);

    const risk: HallucinationRisk = {
      level,
      score,
      reasons,
      mitigations: this.suggestMitigations(reasons)
    };

    this.emit('hallucination:assessed', { claim, risk });
    return risk;
  }

  /**
   * Find internal contradictions in a claim
   */
  private findContradictions(claim: string): string[] {
    const contradictions: string[] = [];
    const lower = claim.toLowerCase();

    // Simple contradiction patterns
    const patterns = [
      { pattern: /always.*never/i, msg: 'Contains both "always" and "never"' },
      { pattern: /all.*none/i, msg: 'Contains both "all" and "none"' },
      { pattern: /everything.*nothing/i, msg: 'Contains both "everything" and "nothing"' },
      { pattern: /is not.*is\s/i, msg: 'Contradictory "is" and "is not"' }
    ];

    for (const { pattern, msg } of patterns) {
      if (pattern.test(lower)) {
        contradictions.push(msg);
      }
    }

    return contradictions;
  }

  /**
   * Convert score to risk level
   */
  private scoreToLevel(score: number): HallucinationRisk['level'] {
    if (score < 0.1) return 'none';
    if (score < 0.3) return 'low';
    if (score < 0.5) return 'medium';
    if (score < 0.8) return 'high';
    return 'certain';
  }

  /**
   * Suggest mitigations for hallucination risks
   */
  private suggestMitigations(reasons: string[]): string[] {
    const mitigations: string[] = [];

    for (const reason of reasons) {
      if (reason.includes('No grounding')) {
        mitigations.push('Verify claim against external sources');
      }
      if (reason.includes('No object')) {
        mitigations.push('Ask for specific references');
      }
      if (reason.includes('fictional')) {
        mitigations.push('Clarify if discussing fiction vs reality');
      }
      if (reason.includes('confidence')) {
        mitigations.push('Request supporting evidence');
      }
      if (reason.includes('coherence')) {
        mitigations.push('Rephrase for clarity');
      }
      if (reason.includes('Contradiction')) {
        mitigations.push('Resolve logical inconsistencies');
      }
    }

    return [...new Set(mitigations)];
  }

  /**
   * Perform abductive reasoning - generate hypotheses from signs
   */
  abduce(observations: Sign[]): AbductiveHypothesis[] {
    this.metrics.abductionsPerformed++;
    const hypotheses: AbductiveHypothesis[] = [];

    // Interpret all observations
    const triads = observations.map(o => this.interpret(o));

    // Find patterns in grounded objects
    const groundedTriads = triads.filter(t => t.grounded);

    if (groundedTriads.length >= 2) {
      // Look for common patterns
      const commonTypes = this.findCommonTypes(groundedTriads);

      for (const type of commonTypes) {
        hypotheses.push({
          hypothesis: `Observations suggest pattern of type: ${type}`,
          evidence: observations,
          plausibility: groundedTriads.length / triads.length,
          testability: 0.7,
          implications: [`If true, expect more ${type} patterns`]
        });
      }
    }

    // Generate causal hypotheses for indices
    const indices = observations.filter(o => o.type === 'index');
    for (const index of indices) {
      const triad = triads.find(t => t.sign.id === index.id);
      if (triad?.object) {
        hypotheses.push({
          hypothesis: `"${index.representamen}" is caused by ${JSON.stringify(triad.object.referent)}`,
          evidence: [index],
          plausibility: triad.coherence,
          testability: 0.8,
          implications: ['Can verify by examining cause-effect chain']
        });
      }
    }

    this.emit('abduction:completed', hypotheses);
    return hypotheses;
  }

  /**
   * Find common types among triads
   */
  private findCommonTypes(triads: Triad[]): string[] {
    const types: Map<string, number> = new Map();

    for (const triad of triads) {
      if (triad.object) {
        const type = triad.object.groundingType;
        types.set(type, (types.get(type) || 0) + 1);
      }
      types.set(triad.sign.type, (types.get(triad.sign.type) || 0) + 1);
    }

    // Return types that appear in majority
    const threshold = triads.length / 2;
    return Array.from(types.entries())
      .filter(([_, count]) => count >= threshold)
      .map(([type, _]) => type);
  }

  /**
   * Meta-semiosis: generate signs about signs
   */
  metaSemiosis(sign: Sign, depth: number = 1): Sign[] {
    if (!this.config.allowMetaSemiosis || depth > this.config.maxInterpretationDepth) {
      return [];
    }

    const metaSigns: Sign[] = [];
    const triad = this.triads.get(sign.id) || this.interpret(sign);

    // Create sign representing the triad itself
    const triadSign: Sign = {
      id: `meta-triad-${sign.id}`,
      representamen: `The interpretation of "${sign.representamen}"`,
      type: 'symbol',
      context: 'meta-semiotic',
      timestamp: Date.now()
    };
    metaSigns.push(triadSign);

    // Create sign representing grounding status
    const groundingSign: Sign = {
      id: `meta-ground-${sign.id}`,
      representamen: triad.grounded
        ? `"${sign.representamen}" is grounded`
        : `"${sign.representamen}" lacks grounding`,
      type: 'index',  // It indicates a state
      context: 'meta-semiotic',
      timestamp: Date.now()
    };
    metaSigns.push(groundingSign);

    // Create sign representing coherence
    const coherenceSign: Sign = {
      id: `meta-coh-${sign.id}`,
      representamen: `Coherence of "${sign.representamen}": ${(triad.coherence * 100).toFixed(0)}%`,
      type: 'symbol',
      context: 'meta-semiotic',
      timestamp: Date.now()
    };
    metaSigns.push(coherenceSign);

    this.metrics.metaSignsGenerated += metaSigns.length;

    // Recursive meta-semiosis if depth allows
    if (depth < this.config.maxInterpretationDepth) {
      for (const metaSign of metaSigns) {
        this.interpret(metaSign);  // Interpret meta-signs
      }
    }

    // Update original interpretant with further signs
    if (triad.interpretant) {
      triad.interpretant.furtherSigns = metaSigns.map(s => s.id);
    }

    this.emit('metasemiosis:completed', { original: sign, metaSigns, depth });
    return metaSigns;
  }

  /**
   * Verify a claim has proper triadic grounding
   */
  verifyTriad(claim: string, object: Object): { valid: boolean; issues: string[] } {
    const issues: string[] = [];

    // Create sign from claim
    const sign: Sign = {
      id: `verify-${Date.now()}`,
      representamen: claim,
      type: 'symbol',
      timestamp: Date.now()
    };

    // Check object validity
    if (!object) {
      issues.push('No object provided');
    } else {
      if (object.groundingType === 'fictional') {
        issues.push('Object is fictional');
      }
      if (object.confidence < this.config.minGroundingConfidence) {
        issues.push(`Object confidence too low: ${object.confidence}`);
      }
      if (this.config.requireDirectGrounding && object.groundingType !== 'direct') {
        issues.push('Direct grounding required but not present');
      }
    }

    // Interpret and check coherence
    const triad = this.interpret(sign);
    if (triad.coherence < 0.5) {
      issues.push(`Low triadic coherence: ${triad.coherence}`);
    }

    return {
      valid: issues.length === 0,
      issues
    };
  }

  /**
   * Get interpretation history
   */
  getHistory(): Sign[] {
    return [...this.signHistory];
  }

  /**
   * Get all triads
   */
  getTriads(): Triad[] {
    return Array.from(this.triads.values());
  }

  /**
   * Get metrics
   */
  getMetrics(): SemioticMetrics {
    return { ...this.metrics };
  }

  /**
   * Clear state
   */
  clear(): void {
    this.triads.clear();
    this.signHistory = [];
    this.metrics = {
      signsProcessed: 0,
      triadsFormed: 0,
      groundedTriads: 0,
      hallucinationsDetected: 0,
      abductionsPerformed: 0,
      metaSignsGenerated: 0
    };
    this.emit('cleared');
  }
}

// ============================================================================
// Simple In-Memory World Model
// ============================================================================

export class SimpleWorldModel implements WorldModel {
  private objects: Map<string, Object>;
  private verifiedObjects: Set<string>;

  constructor() {
    this.objects = new Map();
    this.verifiedObjects = new Set();
  }

  /**
   * Add an object to the world model
   */
  addObject(key: string, referent: unknown, confidence: number = 0.8): Object {
    const object: Object = {
      id: `obj-${key}`,
      referent,
      groundingType: 'direct',
      confidence,
      source: 'manual'
    };
    this.objects.set(key.toLowerCase(), object);
    if (this.objects.size > 1000) {
      const keys = Array.from(this.objects.keys());
      for (let i = 0; i < 200; i++) this.objects.delete(keys[i]);
    }
    return object;
  }

  /**
   * Mark an object as verified
   */
  verifyObject(key: string): void {
    this.verifiedObjects.add(key.toLowerCase());
  }

  /**
   * Lookup an object by claim/key
   */
  lookup(claim: string): Object | null {
    const key = claim.toLowerCase();

    // Direct match
    if (this.objects.has(key)) {
      return this.objects.get(key)!;
    }

    // Partial match
    for (const [k, v] of this.objects) {
      if (key.includes(k) || k.includes(key)) {
        return { ...v, confidence: v.confidence * 0.8 };  // Reduced confidence for partial match
      }
    }

    return null;
  }

  /**
   * Verify an object exists
   */
  verify(object: Object): boolean {
    const key = object.id.replace('obj-', '').toLowerCase();
    return this.verifiedObjects.has(key) || this.objects.has(key);
  }

  /**
   * Get related objects
   */
  getRelated(object: Object): Object[] {
    // Simple implementation - return objects with similar keys
    const related: Object[] = [];
    const key = object.id.replace('obj-', '').toLowerCase();

    for (const [k, v] of this.objects) {
      if (k !== key && (k.includes(key.slice(0, 3)) || key.includes(k.slice(0, 3)))) {
        related.push(v);
      }
    }

    return related;
  }

  /**
   * Get all objects
   */
  getAllObjects(): Object[] {
    return Array.from(this.objects.values());
  }

  /**
   * Clear the world model
   */
  clear(): void {
    this.objects.clear();
    this.verifiedObjects.clear();
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a sign
 */
export function createSign(
  representamen: string,
  type: SignType,
  context?: string
): Sign {
  return {
    id: `sign-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
    representamen,
    type,
    context,
    timestamp: Date.now()
  };
}

/**
 * Create an icon sign
 */
export function createIcon(representamen: string, context?: string): Sign {
  return createSign(representamen, 'icon', context);
}

/**
 * Create an index sign
 */
export function createIndex(representamen: string, context?: string): Sign {
  return createSign(representamen, 'index', context);
}

/**
 * Create a symbol sign
 */
export function createSymbol(representamen: string, context?: string): Sign {
  return createSign(representamen, 'symbol', context);
}

// ============================================================================
// Global Instance
// ============================================================================

let globalLSM: LargeSemiosisModel | null = null;

/**
 * Get global LSM instance
 */
export function getLSM(config?: Partial<SemioticConfig>): LargeSemiosisModel {
  if (!globalLSM) {
    globalLSM = new LargeSemiosisModel(config);
  }
  return globalLSM;
}

/**
 * Reset global LSM
 */
export function resetLSM(): void {
  if (globalLSM) {
    globalLSM.clear();
  }
  globalLSM = null;
}
